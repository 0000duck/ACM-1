# 模板

## 高精度

### 高精度加法

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int L=110;
string add(string a,string b)//只限两个非负整数相加
{
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
    if(na[lmax]) lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
int main()
{
    string a,b;
    while(cin>>a>>b) cout<<add(a,b)<<endl;
    return 0;
}

```

### 高精度减法

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int L=110;
string sub(string a,string b)//只限大的非负整数减小的非负整数
{
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++)
    {
        na[i]-=nb[i];
        if(na[i]<0) na[i]+=10,na[i+1]--;
    }
    while(!na[--lmax]&&lmax>0)  ;lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
int main()
{
    string a,b;
    while(cin>>a>>b) cout<<sub(a,b)<<endl;
    return 0;
}

```

### 高精度乘法

```
//O(n^2)
#include<iostream>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int L=110;  
string mul(string a,string b)//高精度乘法a,b,均为非负整数  
{  
    string s;  
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size();//na存储被乘数，nb存储乘数，nc存储积  
    fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0);//将na,nb,nc都置为0  
    for(int i=La-1;i>=0;i--) na[La-i]=a[i]-'0';//将字符串表示的大整形数转成i整形数组表示的大整形数  
    for(int i=Lb-1;i>=0;i--) nb[Lb-i]=b[i]-'0';  
    for(int i=1;i<=La;i++)  
        for(int j=1;j<=Lb;j++)  
        nc[i+j-1]+=na[i]*nb[j];//a的第i位乘以b的第j位为积的第i+j-1位（先不考虑进位）  
    for(int i=1;i<=La+Lb;i++)  
        nc[i+1]+=nc[i]/10,nc[i]%=10;//统一处理进位  
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';//判断第i+j位上的数字是不是0  
    for(int i=La+Lb-1;i>=1;i--)  
        s+=nc[i]+'0';//将整形数组转成字符串  
    return s;  
}  
int main()  
{  
    string a,b;  
    while(cin>>a>>b) cout<<mul(a,b)<<endl;  
    return 0;  
}  
```

## 字符串

### KMP

```C++
// 用法 提供字符数组a 字符数组b  KMP(a,b)   返回a中b的字串位置 
#include<cstdio>
#include<cstring>
void get_next(char T[],int next[])  
{ 
	//字符串T对应的next数组
	int l = strlen(T); 
	int i=0;
	int j=-1;
	next[0]=-1;
	while(i < l)
	{
		if(j == -1 || T[i] == T[j])
		{
			i++;
			j++;
			next[i] = j;
		}
		else
			j = next[j];
	}
}
int KMP(char *a,char *b)  //匹配a字符串中是否有b字符串  返回匹配到的第一个子串的在a字符串中的头下标 
{
	//a 主串  b 模式串
	int l_a = strlen(a); 
	int l_b = strlen(b);
	int i = 0;  // a的下标
	int j = 0;  // b的下标
	int *next = new int[l_b+10];
	get_next(b,next); 
	while( i < l_a && j < l_b)
	{
		if( j == -1 || a[i] == b[j])
		{
			i++;
			j++;
		}
		else 
			j = next[j];  // 当前字符匹配失败，进行跳转 
		// next数组表示在模式串当前位置匹配失败应该跳转到模式串的下标位置
	}
	if (j == l_b )  //匹配成功
        return i - j;
	return -1;
}
int main()
{
	char a[100];
	char b[100];
	scanf("%s",a);
	scanf("%s",b);
	int f=KMP(a,b);
	printf("%d ",f);
	printf("%c",a[f]); 
	return 0;
}
```



### 字典树

```
#include<bits/stdc++.h>
using namespace std;
const int ALPHABET_SIZE = 26;

struct trieNode{
    int cnt;    //记录该节点代表的单词的个数
    trieNode* children[ALPHABET_SIZE]; //各个子节点
};

trieNode* createTrieNode()
{
    trieNode* node = new trieNode();
    node->cnt = 0;
    for(int i=0; i<ALPHABET_SIZE; i++)
        node->children[i] = NULL;
    return node;
}

void trieInsert(trieNode* root, char* key)
{
    trieNode* node = root;
    char* p  = key;
    while(*p)
    {
        if(node->children[*p - 'a'] == NULL)
            node->children[*p - 'a'] = createTrieNode();
        node = node->children[*p - 'a'];
        ++p;
    }
    node->cnt += 1;
}

int trieSearch(trieNode* root, char* key)
{
    trieNode* node = root;
    char* p = key;
    while(*p && node != NULL)
    {
        node = node->children[*p - 'a'];
        ++p;
    }
    if(node == NULL)
        return 0;
    else
        return node->cnt;
}
```

### AC自动机

```
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;

const int SIZE = 26;
char a[60];
char s[1000010];
struct Node{
    int cnt;   
    Node* fail;     
    Node* next[SIZE]; 
};

Node* createTrieNode()
{
    Node* node = new Node();
    node->fail = NULL;
    node->cnt = 0;
    for(int i=0; i<SIZE; i++)
        node->next[i] = NULL;
    return node;
}

void trieInsert(Node* root, char* key)
{
    Node* node = root;
    char* p  = key;
    while(*p)
    {
        if(node->next[*p - 'a'] == NULL)
            node->next[*p - 'a'] = createTrieNode();
        node = node->next[*p - 'a'];   
        ++p;
    }
    node->cnt += 1;
}


void buildAcAutomation(Node *root)
{
    queue<Node*> q;  
    q.push(root);
    while(!q.empty())
    {
        Node* p = NULL;
        Node* temp = q.front();  q.pop();
        for(int i=0; i<SIZE; i++)
        {
            if(temp->next[i]!=NULL)
            {
                if(temp == root)
                    temp->next[i]->fail = root;
                else
                {
                    //temp->next[i]
                    p = temp->fail; 
                    while(p != NULL)
                    {
                        if(p->next[i] != NULL)
                        {
                            temp->next[i]->fail = p->next[i];
                            break;
                        }
                        p = p->fail;
                    }
                    if(p==NULL)
                        temp->next[i]->fail = root;
                }
                q.push(temp->next[i]);
            }
        }
    }
}

int query(Node* root, char* s)
{
    int cnt = 0;
    int len = strlen(s);
    Node *p = root;        
    for(int i=0; i<len; i++)    
    {
        int v = s[i] - 'a';
        while(p->next[v]==NULL && p!=root)
            p = p->fail;
        p = p->next[v];     
        if(p==NULL)
            p = root;
        Node* temp = p;
        while(temp != root)
        {
            if(temp->cnt >= 0)
            {
                cnt += temp->cnt;
                temp->cnt = -1;
            }
            else
                break;
            temp = temp->fail;
        }
    }
    return cnt;
}

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int N;
        Node* root = createTrieNode();
        scanf("%d",&N);
        for(int i=0; i<N; i++)
        {
            scanf("%s",a);
            trieInsert(root,a);
        }
        buildAcAutomation(root);
        scanf("%s",s);
        int ans = query(root,s);
        printf("%d\n",ans);
    }
    return 0;
}
```

### 马拉车

```
#include<iostream>
#include<string.h>
#include<algorithm>
#include<cstdio>
using namespace std;

char s[1000];
char s_new[2000];
int p[2000];

int Init()
{
    int len = strlen(s);
    s_new[0] = '$';
    s_new[1] = '#';
    int j = 2;
    for (int i = 0; i < len; i++)
    {
        s_new[j++] = s[i];
        s_new[j++] = '#';
    }
    s_new[j] = '\0';  //别忘了哦
    return j;  //返回s_new的长度
}

int Manacher()
{
    int len = Init();  //取得新字符串长度并完成向s_new的转换
    int maxLen = -1;   //最长回文长度
    int id;
    int mx = 0;
    for (int i = 1; i < len; i++)
    {
        if (i < mx)
            p[i] = min(p[2 * id - i], mx - i);
        else
            p[i] = 1;
        while (s_new[i - p[i]] == s_new[i + p[i]])  //不需边界判断，因为左有'$',右有'\0'
            p[i]++;
        if (mx < i + p[i])  //我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i < mx)这句代码，从而提高效率
        {
            id = i;
            mx = i + p[i];
        }
        maxLen = max(maxLen, p[i] - 1);
    }
    return maxLen;
}

int main()
{
    while (printf("请输入字符串：\n"))
    {
        scanf("%s", s);
        printf("最长回文长度为 %d\n\n", Manacher());
    }
    return 0;
}
```

## 数据结构

### 并查集

```c++
int f[maxn];
int rank[maxn]; //树的高度

//初始化
void init()
{
	for(int i=1; i<=maxn; i++)
    {
		f[i] = i;
		rank[i] = 0;
    }
}

//查根
int Find(int x)
{
    if(f[x] == x)
    	return x
    else
    	return f[x] = find(f[x]); //路径压缩
}

//合并 x y 集合
void unite(int x, int y)
{
	x = Find(x);
	y = Find(y);
    if(x==y) return; //x y 已经所属同一集合
    
	/*
	高度优化
	if(rank[x] < rank[y])
		f[x] = y;
	else
	{
		f[y] = x;
		if(rank[x] == rank[y]) rank[x]++;
	}
	*/
    
	f[x] = y; //x作为y的儿子相连
	//f[y] = x; //与上相反
}

```



### 可撤销并查集

```c++
class  UFS
{
private :
    int *fa, *rank ;
    std :: stack < std :: pair < int*, int > > stk ;
public :
    UFS ( ) {   }
    UFS ( int n )
    {
        fa = new int [( const int ) n + 1] ;
        rank = new int [( const int ) n + 1] ;
        memset ( rank, 0, sizeof rank ) ;
        for ( int i = 1 ; i <= n ; ++ i )
            fa [i] = i ;
    }
    inline int find ( int x )
    {
        while ( x ^ fa [x] )
            x = fa [x] ;
        return x ;
    }
    inline int Join ( int x, int y )
    {
        x = find ( x ), y = find ( y ) ;
        if ( x == y )
            return 0 ;
        if ( rank [x] <= rank [y] )
        {
            stk.push ( std :: make_pair ( fa + x, fa [x] ) ) ;
            fa [x] = y ;
            if ( rank [x] == rank [y] )
            {
                stk.push ( std :: make_pair ( rank + y, rank [y] ) ) ;
                ++ rank [y] ;
                return 2 ;
            }
            return 1 ;
        }
        stk.push ( std :: make_pair ( fa + y, fa [y] ) ) ;
        return fa [y] = x,1;
    }
    inline void Undo ( )
    {
        *stk.top ( ).first = stk.top ( ).second ;
        stk.pop ( ) ;
    }
} T ;
```



### 树状数组

![](C:\Users\user\Desktop\20180712221338201.png)

```C++
#include<bits/stdc++.h>
using namespace std;
//优雅的维护前缀和   logn 单点修改 区间查询
//刚开始bit数组要初始全0，然后每读入一个数A[i]就执行一步add(i, A[i])来进行初始化。
const int MAX = 50010;
int bit[MAX+1],n;
int a[MAX];

int lowbit(int i)
{
    return i&(-i);
}

int sum(int i)  //查询   i是5的话，算的就是1~5的和,如果要算2~5就sum(5)-sum(1);
{
    int ans = 0;
    while(i>0)
    {
        ans += bit[i];
        i -= lowbit(i);
    }
    return ans;
}

void update(int i, int x) // 单点更新  更新i-n的所有数据 +x
{
    while(i<=n)
    {
        bit[i] += x;
        i += lowbit(i);
    }
}

void init() //基于前缀数组初始化
{
    memset(bit,0,sizeof(bit));
	for(int i=1; i<=n; i++)
    {
        sacnf("%d",&a[i]);
        update(i,a[i]);
    }
}
```



### 线段树

```C++
#include<cstdio>
using namespace std;

#define Mid ((l+r)>>1)
#define lson rt<<1,l,Mid
#define rson rt<<1|1,Mid+1,r
#define ll long long
const int MAX = 1010000;

ll se[MAX<<2],add[MAX<<2];

void pushUp(int rt)
{
    se[rt] = se[rt<<1] + se[rt<<1|1];
}

void pushDown(int rt, int l, int r)
{
    if(add[rt]!=0)
    {
        //延迟标记向下传递
        add[rt<<1] += add[rt];
        add[rt<<1|1] += add[rt];
        //更新子节点的值
        se[rt<<1] += add[rt]*(ll)(Mid-l+1);
        se[rt<<1|1] += add[rt]*(ll)(r-Mid);
        //清空当前标识
        add[rt] = 0;
    }
}

void build(int rt, int l, int r)
{
    add[rt] = 0;    // 延迟标记
    if(l == r)
        scanf("%lld",&se[rt]);
    else
    {
        build(lson);
        build(rson);
        pushUp(rt);
    }
}

ll query(int rt, int l, int r, int L, int R)   //从l,r 中查询 L,R
{
    if(L<= l && r <= R)
        return se[rt];
    else
    {
        if(add[rt])
            pushDown(rt,l,r);
        ll tmp = 0;
        if(L <= Mid)	//左区间
            tmp += query(lson,L,R);
        if(R > Mid)		//右区间
            tmp += query(rson,L,R);
        return tmp;
    }
}

void updateSingle(int rt,int l,int r,int pos,int num)  
{  
    if(l == r && r == pos){     //到对应的叶结点  
        se[rt] = num;  
    }else{  
        if( pos <= Mid)  
            update(lson,pos,num);  
        if( pos > Mid)          //或者直接else，点不可能同时在两个区间里  
            update(rson,pos,num);  
       	pushUp(rt);
    }  
}  

void update(int rt, int l, int r, int L, int R, ll val)
{
    if(L<=l && r<=R)
    {
        add[rt] += val;
        se[rt] += (ll)(r-l+1)*val;
    }
    else
    {
        if(add[rt])
            pushDown(rt,l,r);
        if(L <= Mid)
            update(lson,L,R,val);
        if(R > Mid)
            update(rson,L,R,val);
        pushUp(rt);
    }
}

int main()
{
    int n,q;
    while(~scanf("%d %d",&n,&q))
    {
        build(1,1,n);
        char op[10];
        int L,R;
        ll va;
        while(q--)
        {
            scanf("%s",op);
            if(op[0] == 'Q')
            {
                scanf("%d %d",&L,&R);
                printf("%lld\n",query(1,1,n,L,R));
            }
            else
            {
                scanf("%d %d %lld",&L,&R,&va);
                update(1,1,n,L,R,va);
            }
        }
    }
    return 0;
}

```



### 线段树  区间加乘

```C++
struct Three
{
    int l;
    int r;
    LL lazya;
    LL lazym;
    LL sum;
};

Three tree[N * 4];
int n, m, MOD;
int ma[N];

void Up(int x)
{
    tree[x].sum = (tree[x << 1].sum + tree[x << 1 | 1].sum) % MOD;
}

void Down(int x)
{
    tree[x << 1].sum = ((tree[x << 1].r - tree[x << 1].l + 1) * tree[x].lazya % MOD + tree[x << 1].sum * tree[x].lazym % MOD) % MOD;
    tree[x << 1 | 1].sum = ((tree[x << 1 | 1].r - tree[x << 1 | 1].l + 1) * tree[x].lazya % MOD + tree[x << 1 | 1].sum * tree[x].lazym % MOD) % MOD;
    tree[x << 1].lazya = (tree[x << 1].lazya * tree[x].lazym % MOD + tree[x].lazya) % MOD;
    tree[x << 1 | 1].lazya = (tree[x << 1 | 1].lazya * tree[x].lazym % MOD + tree[x].lazya) % MOD;
    tree[x << 1].lazym = (tree[x << 1].lazym * tree[x].lazym) % MOD;
    tree[x << 1 | 1].lazym = (tree[x << 1 | 1].lazym * tree[x].lazym) % MOD;
    tree[x].lazya = 0;
    tree[x].lazym = 1;
}

void Build(int x, int l, int r)
{
    tree[x].l = l;
    tree[x].r = r;
    tree[x].lazya = 0;
    tree[x].lazym = 1;
    if(l == r){
        tree[x].sum = ma[l];
    }
    else{
        int mid;

        mid = l + ((r - l) >> 1);
        Build(x << 1, l, mid);
        Build(x << 1 | 1, mid + 1, r);
        Up(x);
    }
}

void Update(int x, int l, int r, int v, int kind)   /// 0 - mul   1 - add
{
    int ll, rr;

    ll = tree[x].l;
    rr = tree[x].r;
    if(l > r){
        return ;
    }
    if(ll == l && rr == r){
        if(kind){	/// Add
            tree[x].lazya = (tree[x].lazya + v) % MOD;
            tree[x].sum = (tree[x].sum + (rr - ll + 1) * v % MOD) % MOD;
        }
        else{
            tree[x].lazya = (tree[x].lazya * v) % MOD;
            tree[x].lazym = (tree[x].lazym * v) % MOD;
            tree[x].sum = (tree[x].sum * v) % MOD;
        }
    }
    else{
        int mid;

        mid = ll + ((rr - ll) >> 1);
        Down(x);
        Update(x << 1, l, min(mid, r), v, kind);
        Update(x << 1 | 1, max(mid + 1, l), r, v, kind);
        Up(x);
    }
}

LL Quary(int x, int l, int r)
{
    int ll, rr;

    if(l > r){
        return 0;
    }
    //printf("%d %d %d\n", x, l, r);
    ll = tree[x].l;
    rr = tree[x].r;
    //printf("%d %d\n", ll, rr);
    if(ll == l && rr == r){
        return tree[x].sum;
    }
    else{
        int mid;
        LL ans;

        ans = 0;
        mid = ll + ((rr - ll) >> 1);
        Down(x);
        ans = (ans + Quary(x << 1, l, min(mid, r))) % MOD;
        ans = (ans + Quary(x << 1 | 1, max(mid + 1, l), r)) % MOD;

        return ans % MOD;
    }
}

```



### 莫队

```C++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 2e6+10;

ll a[maxn];
ll cnt[maxn];
ll ans[maxn];
int n,t,len;
ll Ans;
struct node
{
    int l,r;
    int id;
    int block;
} q[maxn];

//如果左端点所在的块相同 把右端点按照左端点所在的块的奇偶性分类排序   
bool cmp(node& a, node& b)
{
    if(a.block == b.block)
        return a.block&1? a.r<b.r : a.r>b.r ;
        // return a.r<b.r;
    return a.block < b.block;
}


inline void add(int x)
{
    ///
}

inline void dele(int x)
{
    ///
}

int main()
{
    while(~scanf("%d %d",&n,&t))
    {
        len = sqrt(n);
        memset(cnt,0,sizeof(cnt));
        for(int i=1; i<=n; i++)
            scanf("%I64d",&a[i]);
        for(int i=1; i<=t; i++)
        {
            scanf("%d %d",&q[i].l,&q[i].r);
            q[i].id = i;
            q[i].block = q[i].l/len;
        }
        sort(q+1,q+1+t,cmp);
        int l=q[1].l,r=q[1].r;
        Ans = 0;
        for(int i=l; i<=r; ++i)
            add(i);
        for(int i=1; i<=t; ++i)
        {
            while(q[i].l < l)
                add(--l);
            while(q[i].l > l)
                dele(l++);
            while(q[i].r < r)
                dele(r--);
            while(q[i].r > r)
                add(++r);

            ans[q[i].id] = Ans;
        }
        for(int i=1; i<=t; ++i)
            printf("%I64d\n",ans[i]);
    }
    return 0;
}
```



### 主席树

```C++
#include <iostream>
#include <cstdio>
using namespace std;
const int MAX = 20000010;

struct Persistable_Segment_tree
{
    //分别是该位置代表的节点或区间的左儿子右儿子和权值
    int ls,rs;  //记录左右儿子的下标
    int v;
} tr[MAX];


//edit 储存节点版本 注意第一个(下标0)赋值为1表第一个版本 w储存点初始权值
int edit[1 << 20] = {1},w[1 << 20],tot;

int build(int l,int r)  //建立由l-r的数据构成的初始线段树
{
    //此处不能直接用++tot代替pos 因为跳转到子程序中继续搜索下去 tot值会增加 而此处值代表当前节点编号 应不变
    int pos = ++tot;//tot是当前数组末尾的位置 ++tot则是在末尾处新建储存节点或区间的相关信息
    if (l == r)//区间左右相等 即只包括一个点 则只存点权
    {
        tr[pos].v = w[l];//记录初始点权
        return pos;//pos是当前节点的编号 需返回 用以让其父亲节点记录他
    }
    int mid = (l + r) >> 1;
    tr[pos].ls = build(l,mid);//记录当前节点的左儿子编号
    tr[pos].rs = build(++mid,r);//记录当前节点的右儿子编号
    return pos;//返回当前节点编号 需返回 用以让其父亲节点记录他
}


//在ed版本的基础上 修改p点权值为k 记录当前区间最左&&最右端的点l&&r
// 每一次更新都创建一棵新树 其根节点为
int update(int ed,int l,int r,int p,int k)
{
    //此处不能直接++tot代替pos 因为跳转到子程序中继续搜索下去 tot值会增加 而此处值代表当前节点编号 应不变
    int pos = ++tot;//记录当前节点编号
    if (l == r)//搜索到单个节点
    {
        tr[pos].v = k;//记录修改后节点权值
        return pos;//返回当前节点编号 让当前版本的父亲记录他
    }
    tr[pos].ls = tr[ed].ls;//将之前的该节点左儿子复制 (引用-->「把子节点指向前驱节点以备复用」)
    tr[pos].rs = tr[ed].rs;//将之前的该节点右儿子复制 因为之后只会改变两儿子之一的值 这样子可以确定该节点位置
    int mid = (l + r) >> 1;//二分存中点
    if (p <= mid)
        tr[pos].ls = update(tr[ed].ls,l,mid,p,k);//向下寻找 逼近p点 更改pos点的左儿子
    else
        tr[pos].rs = update(tr[ed].rs,mid+1,r,p,k);//向下寻找 逼近p点 更改pos点的右儿子 用tr[ed]的原因是此时tr[pos]只有1深度的孩子的值
    return pos;//返回pos pos作为该点父亲的某个儿子的位置 用以记录
}

int found(int ed,int l,int r,int p)
{
    //ed是 某版本 储存区间1~n的值 的位置
    if (l == r)
        return tr[ed].v;//找到该点 此时ed已经变为 记录当前版本的p点的位置了 其v则是当前版本的p点的权值 返回
    int mid = (l + r) >> 1;
    if (p <= mid)
        return found(tr[ed].ls,l,mid,p);//向下寻找 逼近p点 ed变为ed的左儿子
    else
        return found(tr[ed].rs,mid+1,r,p);//向下寻找 逼近p点 ed变为ed的右儿子
}

int main()
{
    int n,m,edition,mode,node,weight;
    scanf("%d%d",&n,&m);
    for (int a = 1 ; a <= n ; a ++)
        scanf("%d",&w[a]);
    build(1,n);//建树 从区间 1 ~ n 开始递归 找左右儿子
    for (int a = 1 ; a <= m ; a ++)
    {
        scanf("%d%d%d",&edition,&mode,&node);
        if (mode % 2)
        {
            scanf("%d",&weight);
            //以update此时求出tr数组的末尾 edit[a]意为在第a个版本时修改的点为edit[a-1]到edit[a]的点(上面那行程序让本人想了很久很久)
            edit[a] = update(edit[edition],1,n,node,weight);//update解释见子程序
        }
        else
        {
            //因为复制没有创建新节点 因此当前版本的所有点等于当前版本(不是第a-1的版本)之前的所有点
            edit[a] = edit[edition];
            //输出查询某edition的某node的值
            printf("%d\n",found(edit[edition],1,n,node));
        }
    }
    return 0;
}

```



## 计算几何

### 杂项

```c++
#define eps 1e-8

struct point{
    double x,y;
    point(double a=0, double b=0) {x=a; y=b;}
    inline point operator- (const point& t)
    {
        point ret;
        ret.x = x-t.x;
        ret.y = y-t.y;
        return ret;
    }
    inline point operator+ (const point& t)
    {
        point ret;
        ret.x = x+t.x;
        ret.y = y+t.y;
        return ret;
    }
    inline bool operator==(const point t)
    {
        return ( (abs(x-t.x)<eps) && (abs(y-t.y)<eps) );
    }
};

bool zero(x) 
{
   return ((x)>0?(x):-(x))<eps;
}


int dcmp(double x)	//相等返回0 大于返回1 小于返回-1
{
    if(fabs(x)<eps) return 0;
    if(x>0) return 1;
    return -1;
}

//距离
double dist(point a, point b)
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

//叉积  (p1-p0)x(p2-p0)   A*B*Sin(x)   p0p1 x p0p2 判断p2的位置
double xmult(point p0,point p1, point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}

//点积 (P1-P0).(P2-P0)    A*B*Cos(x)
double dmult(point p0,point p1,point p2){
	return (p1.x-p0.x)*(p2.x-p0.x)+(p1.y-p0.y)*(p2.y-p0.y);
}

//求三角形面积
double area(point a, point b, point c)
{
    return 0.5*fabs(xmult(a,b,c));
}

//求a到线段bc的距离
double len(point a,  point b , point c)
{
    double tmp = fabs(xmult(a,b,c));
    return tmp/dist(b,c);
}

//判三点共线  1共线 0共线
int dots_inline(point p1,point p2,point p3){
	return zero(xmult(p1,p2,p3));
}

bool check3p(point A, point B, point x) //检查点x是否在线段AB上
{
    if(!notequal(A,x) || !notequal(B,x))    //端点
        return true;
    if(dots_inline(A,B,x) && dmult(x,A,B)<0)    //共线且 Ax Bx 反向 则在中间
        return true;
    return false;
}

//线段交
//不能判断端点
bool Intersect(point A,point B,point C,point D)     //  通过叉乘判断线段是否相交 
{  
    if(min(A.x,B.x)<=max(C.x,D.x)&&         //  快速排斥实验；  
       min(C.x,D.x)<=max(A.x,B.x)&&  
       min(A.y,B.y)<=max(C.y,D.y)&&  
       min(C.y,D.y)<=max(A.y,B.y)&&  
       xmult(A,B,C)*xmult(A,B,D)<0&&      //  跨立实验；  
       xmult(C,D,A)*xmult(C,D,B)<0)       //  叉乘异号表示在两侧；  
       return true;  
    else return false;  
}
```

### Graham扫描法 凸包 

```C++
//poj 1113
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstring>
using namespace std;
const int INF = 1e9+10;
const int maxn = 1e5+10;
const double PI = 3.1415926;
struct point{
    int x,y;
}p[maxn];

int stack[maxn],top;

//叉积  (p1-p0)x(p2-p0)   A*B*Sin(x)   p0p1 x p0p2 判断p2的位置
double xmult(point p0,point p1, point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}

double dist(point a, point b)
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

bool cmp(point a, point b)  //极角排序  y最小 且x最小的点作为极点  逆时针扫描其他点并排序
{
    int tmp = xmult(p[0],a,b);
    if(tmp>0)
        return true;
    else if(tmp==0 && dist(p[0],a) < dist(p[0],b))
        return true;
    else
        return false;
}

void Graham(int n)	//结果存于 stack
{
    int i;
    if(n<=2)
    {
        for(int i=0; i<n; i++)
            stack[i] = i;
        top=n-1;
    }
    else
    {
        top=1;
        stack[0] = 0;
        stack[1] = 1;
        for(int i=2; i<n; i++)
        {
            while(top>0 && xmult(p[stack[top-1]],p[stack[top]],p[i])<=0 )
                top--;
            stack[++top]=i;
        }
    }
    //top指向最后一个凸包点
}

int main()
{
    int N,L;
    while(~scanf("%d%d",&N,&L))
    {
        int low=0;
        for(int i=0; i<N; i++)
        {
            scanf("%d %d",&p[i].x,&p[i].y);
            //找基点
            if(p[low].y == p[i].y && p[low].x > p[i].x || p[low].y > p[i].y)
                low = i;
        }
        swap(p[0],p[low]);
        sort(p+1,p+N,cmp);
        Graham(N);

        double res = 0;
        for(int i=0; i<top; i++)
            res += dist(p[stack[i]],p[stack[i+1]]);
        res += dist(p[stack[0]],p[stack[top]]);
        res += 2*PI*L;
        printf("%d\n",(int)(res+0.5));
    }
}

```



###旋转卡壳

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define eps 1e-8
const int maxn = 1e5+10;
struct point
{
    double x,y;
} p[maxn];

int s[maxn],top;

//叉积  (p1-p0)x(p2-p0)   A*B*Sin(x)   p0p1 x p0p2 判断p2的位置
double xmult(point p0,point p1, point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}

double dmult(point p0,point p1,point p2){
	return (p1.x-p0.x)*(p2.x-p0.x)+(p1.y-p0.y)*(p2.y-p0.y);
}

double dist(point a, point b)
{
    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}

double len(point a,  point b , point c)
{
    double tmp = fabs(xmult(a,b,c));
    return tmp/dist(b,c);
}


int dcmp(double x)	//相等返回0 大于返回1 小于返回-1
{
    if(fabs(x)<eps) return 0;
    if(x>0) return 1;
    return -1;
}

bool cmp(point a, point b)  //极角排序  y最小 且x最小的点作为极点  逆时针扫描其他点并排序
{
    int tmp = xmult(p[0],a,b);
    if(tmp>0)
        return true;
    else if(tmp==0 && dist(p[0],a) < dist(p[0],b))
        return true;
    else
        return false;
}

void Graham(int n)	//结果存于 stack
{
    if(n<=2)
    {
        for(int i=0; i<n; i++)
            s[i] = i;
        top=n-1;
    }
    else
    {
        top=1;
        s[0] = 0;
        s[1] = 1;
        for(int i=2; i<n; i++)
        {
            while(top>0 && xmult(p[s[top-1]],p[s[top]],p[i]) <= 0 )
                top--;
            s[++top]=i;
        }
    }
    top++;
}

double RC()   //旋转卡壳
{
    if(top <= 2)    //凸包退化为线段
        return dist(p[s[0]],p[s[1]]);
    int cur=1;
    double ans = 0;
    int L,R=1; //最小矩形覆盖
    for(int i = 0; i != top ; i ++)
    {
        //每次对于直线 s[i]-s[i+1]进行旋转卡壳， 找到对面最远的点
        //凸包直径
        while( dcmp(abs(xmult(p[s[(i+1)%top]],p[s[i%top]],p[s[(cur+1)%top]])) - abs(xmult(p[s[(i+1)%top]],p[s[i%top]],p[s[cur%top]]))) > 0 )  //求最上面的点
            cur = (cur + 1)%top;
        ans = max(ans, max(dist(p[s[(i+1)%top]],p[s[cur]]), dist(p[s[i%top]],p[s[cur]])) );
        //凸包宽度
        while( dcmp(abs(xmult(p[s[(i+1)%top]],p[s[i%top]],p[s[(cur+1)%top]])) - abs(xmult(p[s[(i+1)%top]],p[s[i%top]],p[s[cur%top]]))) > 0 )
            cur = (cur + 1)%top;
        ans = min(ans, len(p[s[cur]],p[s[i]],p[s[(i+1)%top]]));
        //找到最上、最左、最右的点
        //矩形覆盖
        while( dcmp(abs(xmult(p[s[(i+1)%top]],p[s[i%top]],p[s[(cur+1)%top]])) - abs(xmult(p[s[(i+1)%top]],p[s[i%top]],p[s[cur%top]]))) > 0 )
            cur = (cur + 1)%top;    //上
        while( dcmp(dmult(p[s[cur]],p[s[(cur+1)%top]],p[s[(R+1)%top]])-dmult(p[s[cur]],p[s[(cur+1)%top]],p[s[R]]))>0)
            R = (R+1)%top;  //右
        if(i==0) L=R;
        while( dcmp(dmult(p[s[cur]],p[s[(cur+1)%top]],p[s[(L+1)%top]])-dmult(p[s[cur]],p[s[(cur+1)%top]],p[s[L]]))<=0)
            L=(L+1)%top;    //左
        double area = fabs(xmult(p[s[i]],p[s[(i+1)%top]],p[s[cur]]))*fabs( dmult(p[s[i]],p[s[(i+1)%top]],p[s[R]])-dmult(p[s[i]],p[s[(i+1)%top]],p[s[L]]) );
        if(ans > area) ans = area;
    }
    return ans;
}
```



### 多边形面积

```C++
//极角排序
//叉乘  vec1 x vec2 = |vec1|*|vec2|*sin(alpha)
//面积 s += 0.5*(x[i] - x[i -1])* (y[i] + y[i - 1]);
//依次遍历即可
```



## 其他

###Simpson公式

```c++
double simpson(double a,double b)//这里是辛普森公式
{
    double c=(a+b)/2.0;
    return (f(a)+f(b)+4.0*f(c))*(b-a)/6.0;
}
```

### 离散化

```c++
vector<int> id;
//离散化后为id数组下标
int getid(int x)
{
    return lower_bound(id.begin(), id.end(), x) - id.begin() + 1;
}

int main()
{
    int n;

    scanf("%d", &n);
    for(int i = 1; i <= n; i ++){
        int x;

        scanf("%d", &x);
        id.pb(x);
    }
    sort(id.begin(), id.end());
    id.erase(unique(id.begin(), id.end()), id.end());
}
```



### 读入挂

```c++
inline int read() {
    char c=getchar(); int x=0,f=1;
    while(c<'0'||c>'9') {if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
    return x*f;
}
```



### 表达式求值

```C++
///注意前导零  不支持小数
///中缀表达式转后缀表达式
#include<bits/stdc++.h>
#include<stack>
const int MAX=100;
using namespace std;
char pp[MAX];//存储转换后的后缀表达式
void trans(char *str)//将中缀表达式转换后缀表达式
{
    stack<char>ss;
    int i,j;
    i=0;
    j=0;
    while(str[i]!='#')
    {
        if(str[i]=='(')	///优先级
        {
            ss.push(str[i]);
        }
        else if(str[i]==')')
        {
            while(ss.top()!='(')
            {
                pp[j++]=ss.top();
                ss.pop();
            }
            ss.pop();
 
        }
        else if(str[i]=='+'||str[i]=='-')
        {
            while(!ss.empty()&&ss.top()!='(')
            {
                pp[j++]=ss.top();
                ss.pop();
            }
            ss.push(str[i]);
        }
        else if(str[i]=='*'||str[i]=='/')
        {
            while((!ss.empty()&&ss.top()=='*')||(!ss.empty()&&ss.top()=='/'))
            {
                pp[j++]=ss.top();
                ss.pop();
            }
            ss.push(str[i]);
        }
        else if(str[i]==' ')
        {
            i++;
            continue;
        }
        else
        {
            while(str[i]>='0'&&str[i]<='9')
            {
                pp[j++]=str[i];
                i++;
            }
            i--;
            pp[j++]='#';
        }
        i++;
    }
    while(!ss.empty())
    {
        pp[j++]=ss.top();
        ss.pop();
    }
    pp[j]='#';
    for(int k=0; k<=j; k++)//输出转化后的后缀表达式
    {
        printf("%c",pp[k]);
    }
    printf("\n");
}
void compvalue()//计算后缀表达式的值
{
    double d;
    stack<double>mm;
    int i;
    i=0;
    while(pp[i]!='#')
    {
        if(pp[i]=='+')
        {
            double r=mm.top();
            mm.pop();
            double l=mm.top();
            mm.pop();
            double result=l+r;
            mm.push(result);
        }
        else if(pp[i]=='-')
        {
            double r=mm.top();
            mm.pop();
            double l=mm.top();
            mm.pop();
            double result=l-r;
            mm.push(result);
        }
        else if(pp[i]=='*')
        {
            double r=mm.top();
            mm.pop();
            double l=mm.top();
            mm.pop();
            double result=l*r;
            mm.push(result);
        }
        else if(pp[i]=='/')
        {
            double r=mm.top();
            mm.pop();
            double l=mm.top();
            mm.pop();
            double result=l/r;
            mm.push(result);
        }
        else
        {
          d=0;
          while(pp[i]>='0'&&pp[i]<='9')
          {
              d=10*d+pp[i]-'0';
              i++;
          }
          mm.push(d);
        }
        i++;
    }
    printf("%lf\n",mm.top());
}
int main()
{
    char str[MAX];
    while(gets(str))
    {
        trans(str);
        compvalue();
    }
    return 0;
}
```

### 归并求逆序对

```c++
#include <iostream>
using namespace std;

int n=0;//全局变量，用于统计逆序对数

void merge(int a[],int first,int mid,int last)
{
    int *temp = new int[last-first+1];//临时数组，用于临时存放比较后的数字
    int i=first,j=mid+1,k=0;
    while(i<=mid&&j<=last)//遍历比较左右两个部分
    {
        if(a[i]<=a[j])
            temp[k++] = a[i++]; //左半部分元素小于右半部分的元素，将左边该元素存入临时数组
        else
        {
            temp[k++] = a[j++];
            n=n+(mid-i+1);//统计左半边能和右半边该元素构成的逆序对数
        }
    }
    while(i<=mid)
        temp[k++]=a[i++];
    while(j<=last)
        temp[k++]=a[j++];
    for(i=0; i < k; i++)
        a[first + i] = temp[i];//从临时数组取出放回原数组
}

void mergesort(int a[],int first,int last)
{
    if(first < last)
    {
        int mid = (first+last)/2;
        mergesort(a,first,mid);//递归排序左半部分
        mergesort(a,mid+1,last);//递归排序右半部分
        merge(a,first,mid,last);//将处理后的两个部分合并
    }
}

int main()
{
    int a[6] = {1,2,3,4,5,6};
    cout<<"序列:";
    for(int i=0; i<6; i++)
        cout<< a[i] <<" ";
    cout << endl;
    mergesort(a,0,5);
    cout << endl<< "逆序对数：" << n << endl;
    return 0;
}
```



### 快速幂

```C++
long long fun( int a, int b ) //a^b
{
    long long int r = 1;
    int base = a;
    while( b != 0 ) 
    {
        if(b & 1)//判断奇偶性
        {
            r *= base;
        }
         base *= base; //注意：a^{2^7}=a^{2^6} * a^{2^6} ，而不是 a^{2^7}=a^{2^6} * a ，所以这是对的。
        b /= 2;//与b=b>>1相同
    }
    return r;
}

int quickpow(int a,int n,int k) //a^n%k
{
    int b = 1;
    while (n)
    {
          if (n & 1)
             b = (b*a)%k;
          n = n >> 1 ;
          a = (a*a)%k;
    }
    return b;
}
```

### 矩阵快速幂

```
const int maxn = 2;
const int mod = 7;
struct matrix
{
    int m[2][2];
};

matrix multi(matrix a, matrix b)
{
    matrix tmp;
    for(int i=0; i<maxn; i++)
    {
        for(int j=0; j<maxn; j++)
        {
            tmp.m[i][j] = 0;
            for(int k=0; k<maxn; k++)
                tmp.m[i][j] += (a.m[i][k]*b.m[k][j])%mod;
            tmp.m[i][j]%=mod;
        }
    }
    return tmp;
}

matrix fastPow(matrix base, int n)
{
    matrix ans;
    for(int i=0; i<maxn; i++)
        for(int j=0; j<maxn; j++)
            ans.m[i][j] = (i==j);
    while(n)
    {
        if(n&1)
            ans = multi(ans, base);
        base = multi(base, base);
        n>>=1;
    }
    return ans;
}
```

### 高斯消元

```C++
#include<bits/stdc++.h>
#define N 205
using namespace std;
const double eps=1e-8;
int n;
double a[N][N],del;
bool gauss(){
    for(int i=1;i<=n;i++){
        int k=i;
        for(int j=i+1;j<=n;j++)if(fabs(a[j][i])>fabs(a[k][i]))k=j;
        if(fabs(del=a[k][i])<eps)return 0;
        for(int j=i;j<=n+1;j++)swap(a[i][j],a[k][j]);
        for(int j=i;j<=n+1;j++)a[i][j]/=del;
        for(k=1;k<=n;k++)if(k!=i){
            del=a[k][i];
            for(int j=i;j<=n+1;j++)a[k][j]-=a[i][j]*del;
        }
    }
    return 1;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n+1;j++)scanf("%lf",&a[i][j]);
    bool flag=gauss();
    if(!flag)puts("No Solution");
    else for(int i=1;i<=n;i++)printf("%.2lf\n",a[i][n+1]);
    return 0;
}
```



## 图论

### 链式前向星

```c++
const int MAXM = 5e5+10;    ///最大边数
const int MAXN = 1e5+10;    ///最大点数
struct Edge{
    int next;   ///下一条边的存储下标
    int to;     ///这条边的终点
    int w;      ///权值
};

Edge edge[MAXN]
int n, m, top;
int head[MAXN];  ///head[i]表示以i为起点的第一条边的存储下标

void Add(int from, int to, int w)   ///起点, 终点v, 权值w
{
    edge[top].to = to;
    edge[top].w = w;
    edge[top].next = head[from];
    head[from] = top;
    top++;
}

for(int i = head[u]; i != -1; i = node[i].ne)
{
  /// 遍历 以u为起点的所有边
}

void ini()
{
  top = 0;
  memset(head, -1, sizeof(head));
}
```

### SPFA(链式前向星)

```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <queue>
#include <string.h>
using namespace std;
 
const int INF=0x3f3f3f3f;
const int maxm=511111;
const int maxn=111111;
 
struct EdgeNode
{
    int to;
    int w;
    int next;
};
 
EdgeNode edges[maxm];
int N,M;
int head[maxn],edge;
bool vis[maxn];
queue <int> que;
int dis[maxn];
 
void addedge(int u,int v,int c)
{
    edges[edge].w=c,edges[edge].to=v;
    edges[edge].next=head[u];
    head[u]=edge++;
}

void init()
{
    memset(head,-1,sizeof(head));
    edge=0;
}
 
void spfa(int s,int n)//单源最短路(s为起点，n为节点总数)
{
    int u;
    for (int i=0; i<=n; i++)
        dis[i]=INF;
    memset(vis,0,sizeof(vis));
    while (!que.empty()) que.pop();
    que.push(s);
    vis[s]=true;
    dis[s]=0;
    while (!que.empty())
    {
        u=que.front();
        que.pop();
        vis[u]=false;
        for (int i=head[u]; i!=-1; i=edges[i].next)
        {
            int v=edges[i].to;
            int w=edges[i].w;
            if (dis[v]>dis[u]+w)
            {
                dis[v]=dis[u]+w;
                if (!vis[v])
                {
                    vis[v]=true;
                    que.push(v);
                }
            }
        }
    }
}
```



### 匈牙利算法  二部图匹配

```C++
const int N = 550;

int ma[N][N];	/// 图
int used[N];    /// 另一边的使用情况
int ne[N];
//匹配结果存在 数组ne中
bool Find(int x)
{
    for-0(int i = 1; i <= m; i ++){   /// 遍历另一边
        if(ma[x][i] && !used[i])
        {
            used[i] = 1;
            if(!ne[i] || Find(ne[i])) /// 没有就直接上 || 如果有就腾开再上
            {  
                ne[i] = x;
                return true;
            }
        }
    }
    return false;
}

int match()
{
    int ans;

    ans = 0;
    for(int i = 1; i <= n; i ++)   /// 遍历一边
    {   
        memset(used, 0, sizeof(used));
        if(Find(i))
            ans++;
    }
    return ans;
}
```



## STL

 ### String

```C++
string类的字符操作：
const char &operator[](int n)const;
const char &at(int n)const;
char &operator[](int n);
char &at(int n);
operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。
const char *data()const;//返回一个非null终止的c字符数组
const char *c_str()const;//返回一个以null终止的c字符串
int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目

string的特性描述:
int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）
int max_size()const;    //返回string对象中可存放的最大字符串的长度
int size()const;        //返回当前字符串的大小
int length()const;       //返回当前字符串的长度
bool empty()const;        //当前字符串是否为空
void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分

string类的输入输出操作:
string类重载运算符operator>>用于输入，同样重载运算符operator<<用于输出操作。
函数getline(istream &in,string &s);用于从输入流in中读取字符串到s中，以换行符'\n'分开。

string的赋值：
string &operator=(const string &s);//把字符串s赋给当前字符串
string &assign(const char *s);//用c类型字符串s赋值
string &assign(const char *s,int n);//用c字符串s开始的n个字符赋值
string &assign(const string &s);//把字符串s赋给当前字符串
string &assign(int n,char c);//用n个字符c赋值给当前字符串
string &assign(const string &s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串
string &assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串

string的连接：
string &operator+=(const string &s);//把字符串s连接到当前字符串的结尾 
string &append(const char *s);            //把c类型字符串s连接到当前字符串结尾
string &append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾
string &append(const string &s);    //同operator+=()
string &append(const string &s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾
string &append(int n,char c);        //在当前字符串结尾添加n个字符c
string &append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾


string的比较：
bool operator==(const string &s1,const string &s2)const;//比较两个字符串是否相等
运算符">","<",">=","<=","!="均被重载用于字符串的比较；
int compare(const string &s) const;//比较当前字符串和s的大小
int compare(int pos, int n,const string &s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小
int compare(int pos, int n,const string &s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中

//pos2开始的n2个字符组成的字符串的大小
int compare(const char *s) const;
int compare(int pos, int n,const char *s) const;
int compare(int pos, int n,const char *s, int pos2) const;
compare函数在>时返回1，<时返回-1，==时返回0  


string的子串：
string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串

string的交换：
void swap(string &s2);    //交换当前字符串与s2的值


string类的查找函数： 
int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置
int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置
int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置
int find(const string &s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置
//查找成功时返回所在位置，失败返回string::npos的值 
int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置
int rfind(const char *s, int pos = npos) const;
int rfind(const char *s, int pos, int n = npos) const;
int rfind(const string &s,int pos = npos) const;
//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值 
int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置
int find_first_of(const char *s, int pos = 0) const;
int find_first_of(const char *s, int pos, int n) const;
int find_first_of(const string &s,int pos = 0) const;
//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos 
int find_first_not_of(char c, int pos = 0) const;
int find_first_not_of(const char *s, int pos = 0) const;
int find_first_not_of(const char *s, int pos,int n) const;
int find_first_not_of(const string &s,int pos = 0) const;
//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos 
int find_last_of(char c, int pos = npos) const;
int find_last_of(const char *s, int pos = npos) const;
int find_last_of(const char *s, int pos, int n = npos) const;
int find_last_of(const string &s,int pos = npos) const; 
int find_last_not_of(char c, int pos = npos) const;
int find_last_not_of(const char *s, int pos = npos) const;
int find_last_not_of(const char *s, int pos, int n) const;
int find_last_not_of(const string &s,int pos = npos) const;
//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找


string类的替换函数： 
string &replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串s
string &replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符
string &replace(int p0, int n0,const string &s);//删除从p0开始的n0个字符，然后在p0处插入串s
string &replace(int p0, int n0,const string &s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符
string &replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c
string &replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串s
string &replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符
string &replace(iterator first0, iterator last0,const string &s);//把[first0，last0）之间的部分替换为串s
string &replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c
string &replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串


string类的插入函数： 
string &insert(int p0, const char *s);
string &insert(int p0, const char *s, int n);
string &insert(int p0,const string &s);
string &insert(int p0,const string &s, int pos, int n);
//前4个函数在p0位置插入字符串s中pos开始的前n个字符
string &insert(int p0, int n, char c);//此函数在p0处插入n个字符c
iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置
void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符
void insert(iterator it, int n, char c);//在it处插入n个字符c


string类的删除函数 
iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置
iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置
string &erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串


string类的迭代器处理： 
string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。
用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：
const_iterator begin()const;
iterator begin();                //返回string的起始位置
const_iterator end()const;
iterator end();                    //返回string的最后一个字符后面的位置
const_iterator rbegin()const;
iterator rbegin();                //返回string的最后一个字符的位置
const_iterator rend()const;
iterator rend();                    //返回string第一个字符位置的前面
rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现
```



### Pair

```
pair 可以看作是内部有两个元素的结构体，且这两个元素是可以指定的 
示例如下：
struct pair{
	typeName1 first;
	typeName2 second;
} 
pair 的定义
头文件#include<utility>和using namespace std；
注意：map头文件中自动添加utility头文件
pair <typeName1, typeName2> name； 
pair <string, int> p;
pair <string, int> p("haha", 5);//定义并对其初始化
注意：
临时构建一个pair的两种方法
1.将类型定义写在前面，后面用小括号内两个元素的方式
pair<string, int>("haha", 5); 
2.使用make_pair函数 
make_pair("haha", 5);
```



### Bitset

```
//bitset定长
bitset<n> b;                           //b有n位,每位都为0;
bitset<n> b(u);                       //b是unsigned long型u的副本
bitset<n> b(s);                       //b是string对象s中含有n位字符串的副本
bitset<n> b(s, pos, n);             //b是s中从pos位置开始的n个位置的副本
bitset<n> b(s,pos);                 //b从s的pos位置开始取值到s末尾(注取的值从b的右端开始)

b.any();                                 //查找b是否存在1?
b.none();                               //b中不存在1吗?
b.count();                              //b中1的个数
b.size();                                //b的位数
b[pos];                                 //访问b中pos处的数值
b.test(pos);                          //检测b中pos处是否为1
b.set();                                //把b中所有位 置为1
b.set(pos);                           //把b中pos位置为1
b.reset();                             //把b中所有位置为0
b.reset(pos);                         //把b中pos位置为0
b.flip();                                //b中所有二进制位取反
b.flip(pos);                           //b中在pos处的二进制位取反
b.to_ulong;                           //返回一个同值得unsigned long值
os << b;                              //把b中位集输出
```



### 函数

```
// a:   1 2 2 3 5 5 5 6 7 9 9
// idx: 0 1 2 3 4 5 6 7 8 9 10
lower_bound(a,a+n,k);  //查5返回下标4
返回一个非递减序列[first, last)中的第一个大于等于值val的位置。
upper_bound(a,a+n,k);  //查5返回下标7   找到第一个比k大的数
返回一个非递减序列[first, last)中的第一个大于值val的位置。
//查4均返回4

unique(a,a+n)
unique的作用是“去掉”容器中相邻元素的重复元素（不一定要求数组有序），它会把重复的元素添加到容器末尾（所以数组大小并没有改变），而返回值是去重之后的尾地址
 sz = unique(a,a + n) - a;
 //去重后size
```

